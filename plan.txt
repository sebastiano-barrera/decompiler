
- now: proceed without gui, power up CLI/textual interface if needed

- [x] precise testing of calling convention
    - [x] outgoing calls
        - workshopping the xform pass by using decompiler_cli
            - current test case: func097_out
            - [x] why is `void *x = NULL` compiled to a 32-bit register set?
                    (e.g. `mov esi,0` instead of `mov rsi,0`)
                    - becuase of fucking x86_64!
            - [x] fix: infinite loop when compiling with -O0
                cmd: gcc -O0 -gdwarf -masm=intel -o decompiler/test-data/x86_64_callconv decompiler/test-data/x86_64_callconv.c
                cmd: cargo run --bin decompiler_cli -- --exe decompiler/test-data/x86_64_callconv --func func097_out
            - [x] wrong connection of struct members to values?

        - [x] transform into proper generated tests, like for incoming calls

- [x] separate raw bytes from typed consts
    - why though?
    - approach:
        - change Insn::Const into Insn::Bytes, Insn::ConstInt
        - introduce Insn::Cast?

    - [x] float literals

- [x] either support arbitrarily sized integer literals (Insn::Int), or find a
suitable alternative

    - the suitable alternative, turns out, is to just ignore this. Large (> 8
    bytes) values are represented as whatever (maybe a Struct, or a Concat chain
    of multiple large parts), while small values are fine with Int literals.
    In both cases, Part/Widen/Concat chains can be collapsed and extract a Const
    if it's at all possible to do so.

- [x] large scale testing and tracking

    - I expect that large-scale is correlated with lower-value/significance
    tests; high-value tests are more likely to be highly specific

    - what could be some good large-scale tests? decompile every function and
    chack that...

        - [x] the decompiler does not panic on any of them

            - in particular, for debug builds (which is what integration tests
            use), also check a few additional invariants for the SSA code (after
            construction and again after transforms)

        - [~] there are no unsupported asm instructions

            - (delayed; just list insns for now)

            - this only makes sense for a reference application that was
            explicitly selected as "normal enough" (close to our target).
            implementing the whole of x86_64 is pretty much impossible!

            - redis-server is fine for the purpose. maybe some other data
            processing application. maybe a driver for a specific bit of
            hardware? would be cool to target low-level applications like those.

            - would be cool to do this sort of "search" tasks by making the
            output structured and then doing the search with external tools
            (e.g. jq).

- [x] cache type info

    - any particular logic to invalidate the cache across different (but potentially
    compatible) build?

- [x] structured output (to plug the decompiler into other things)
    - JSON?
    - graphviz for CFG?
    - SQLite?

    - this is very important for me to 'live into' the product, so I can find bugs
    and prioritize them based on how much they affect the output; also, invent and
    prioritize new features.

    - any UI must be based on this data-based representation. I don't want to work
    on both things independently.

        - if the UI is written in Rust, a Rust API for the data structure might be
        sufficient.

        - if the UI is to be written into something else, then the data-based
        representation might also be *the* input representation to be transformed
        into a GUI

- [x] gui: restore
    - evaluate HTML/web interface approach. (I'm thinking: better suited to our
    output, which is fundamentally text, with more or less interactivity added on top)

-- from here on, user-facing features have a gui version and a cli version

- [x] feasibility study: web app general structure (with edit API requests AND ALSO localized edits) (and also learn Solid.js):
    - [x] decide what the editable data structure looks like (for the experiment)
        - needs to have some part that is editable AND appears in multiple places

    - [x] basic server
    - [x] view API
    - [x] edit API
    - [x] frontend boilerplate with Preact
    - [x] view
    - [x] edit workflow:
        - [x] localized
        - [x] call edit API + refresh

- [ ] data oriented interface
    - [ ] standardized serde-able output
    - [ ] standardized serde-able input parameters (other than the executable itself)

- [ ] use type info
    - [x] struct member accesses
    - [ ] ssa: value types
        - [x] cli
        - [ ] gui
    - [ ] ast: value types
    - [ ] function prototype
    - [ ] show type (the type itself: details, name, structure, links, etc.)
    - [ ] enum values
        - initialize with DWARF, allow user edits

- [ ] string literals


--- The following are to be prioritized and grouped

- [ ] custom block ordering

    - does it make sense for decompiler_cli?

- [ ] gui: user-editable identifiers/names

- [ ] ast: clickable marker for inline values
    - in general, it should be possible to see ANY correspondence between AST parts and
    SSA insns

- [ ] gui: add ASM view
    - make it possible to show/hide
    - this should make custom block ordering significantly faster
    - [ ] add ASM view
    - [ ] make ASM, SSA toggleable
        - [ ] refactor: make views more independent from each other and from the "column allocation"

- [ ] go back to single executable, single function at a time
    - increased code complexity is not worth it. can be paid to higher benefit later

- [ ] attach errors/warnings to ssa instructions wherever applicable
    - reasonable approximation: create a panel for tracing that allows searching,
    also based on language elements (registers, types, etc.)

- [ ] gui: multiple functions (tabs?)

- [ ] fully data-driven asm->mil?

- [ ] remove horizontal padding/margin in ast's Flow seqs

- [ ] better syntax for deref

- [ ] cross-view highlighting
    - when hovering a register/block, highlight every corresponding item in every view (both same view and the others)

- [ ] highlight full blocks, too

- [ ] arbitrary block ordering for AST
    - eventually going to become user-editable
