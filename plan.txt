
- now: proceed without gui, power up CLI/textual interface if needed

- [x] precise testing of calling convention
    - [x] outgoing calls
        - workshopping the xform pass by using decompiler_cli
            - current test case: func097_out
            - [x] why is `void *x = NULL` compiled to a 32-bit register set?
                    (e.g. `mov esi,0` instead of `mov rsi,0`)
                    - becuase of fucking x86_64!
            - [x] fix: infinite loop when compiling with -O0
                cmd: gcc -O0 -gdwarf -masm=intel -o decompiler/test-data/x86_64_callconv decompiler/test-data/x86_64_callconv.c
                cmd: cargo run --bin decompiler_cli -- --exe decompiler/test-data/x86_64_callconv --func func097_out
            - [x] wrong connection of struct members to values?

        - [x] transform into proper generated tests, like for incoming calls

- [x] separate raw bytes from typed consts
    - why though?
    - approach:
        - change Insn::Const into Insn::Bytes, Insn::ConstInt
        - introduce Insn::Cast?

    - [x] float literals

- [ ] either support arbitrarily sized integer literals (Insn::Int), or find a
suitable alternative

- [ ] large scale testing and tracking

    - I expect that large-scale is correlated with lower-value/significance
    tests; high-value tests are more likely to be highly specific

    - what could be some good large-scale tests?

        - decompile every function and check that the decompiler does not panic
        on any of them

            - in particular, for debug builds (which is what integration tests
            use), also check a few additional invariants for the SSA code (after
            construction and again after transforms)

        - decompile every function and check that no there are no unsupported
        asm instructions

            - this only makes sense for a reference application that was
            explicitly selected as "normal enough" (close to our target).
            implementing the whole of x86_64 is pretty much impossible!

            - redis-server is fine for the purpose. maybe some other data
            processing application. maybe a driver for a specific bit of
            hardware? would be cool to target low-level applications like those.



- [ ] use type info
    - [x] struct member accesses
    - [ ] show in ast
    - [ ] function prototype
    - [x] ssa: value types
    - [ ] ast: value types
    - [ ] enum values
        - initialize with DWARF, allow user edits

- [ ] string literals

- [ ] gui: restore
    - evaluate HTML/web interface approach. (I'm thinking: better suited to our output, which is fundamentally text, with more or less interactivity added on top)

--- The following are to be prioritized and grouped

- [ ] custom block ordering

    - does it make sense for decompiler_cli?

- [ ] ast: clickable marker for inline values
    - in general, it should be possible to see ANY correspondence between AST parts and
    SSA insns

- [ ] gui: add ASM view
    - make it possible to show/hide
    - this should make custom block ordering significantly faster
    - [ ] add ASM view
    - [ ] make ASM, SSA toggleable
        - [ ] refactor: make views more independent from each other and from the "column allocation"

- [ ] go back to single executable, single function at a time
    - increased code complexity is not worth it. can be paid to higher benefit later

- [ ] attach errors/warnings to ssa instructions wherever applicable

- [ ] gui: user-editable identifiers/names

- [ ] gui: multiple functions (tabs?)

- [ ] fully data-driven asm->mil?

- [ ] remove horizontal padding/margin in ast's Flow seqs

- [ ] better syntax for deref

- [ ] cross-view highlighting
    - when hovering a register/block, highlight every corresponding item in every view (both same view and the others)

- [ ] highlight full blocks, too

- [ ] arbitrary block ordering for AST
    - eventually going to become user-editable
