---
source: decompiler/tests/test_tool.rs
expression: out
---
 --- mil
program  98 instrs
    0 r12 <- Ancestral { anc_name: AncestralName("stack_bottom"), reg_type: Bytes(8) }
    1 r3 <- Ancestral { anc_name: AncestralName("PF"), reg_type: Bool }
    2 r4 <- Ancestral { anc_name: AncestralName("AF"), reg_type: Bool }
    3 r5 <- Ancestral { anc_name: AncestralName("ZF"), reg_type: Bool }
    4 r6 <- Ancestral { anc_name: AncestralName("SF"), reg_type: Bool }
    5 r7 <- Ancestral { anc_name: AncestralName("TF"), reg_type: Bool }
    6 r8 <- Ancestral { anc_name: AncestralName("IF"), reg_type: Bool }
    7 r9 <- Ancestral { anc_name: AncestralName("DF"), reg_type: Bool }
    8 r10 <- Ancestral { anc_name: AncestralName("OF"), reg_type: Bool }
    9 r11 <- Ancestral { anc_name: AncestralName("RBP"), reg_type: Bytes(8) }
   10 r12 <- Ancestral { anc_name: AncestralName("RSP"), reg_type: Bytes(8) }
   11 r13 <- Ancestral { anc_name: AncestralName("RIP"), reg_type: Bytes(8) }
   12 r14 <- Ancestral { anc_name: AncestralName("RDI"), reg_type: Bytes(8) }
   13 r15 <- Ancestral { anc_name: AncestralName("RSI"), reg_type: Bytes(8) }
   14 r16 <- Ancestral { anc_name: AncestralName("RAX"), reg_type: Bytes(8) }
   15 r17 <- Ancestral { anc_name: AncestralName("RBX"), reg_type: Bytes(8) }
   16 r18 <- Ancestral { anc_name: AncestralName("RCX"), reg_type: Bytes(8) }
   17 r19 <- Ancestral { anc_name: AncestralName("RDX"), reg_type: Bytes(8) }
   18 r20 <- Ancestral { anc_name: AncestralName("R8"), reg_type: Bytes(8) }
   19 r21 <- Ancestral { anc_name: AncestralName("R9"), reg_type: Bytes(8) }
   20 r22 <- Ancestral { anc_name: AncestralName("R10"), reg_type: Bytes(8) }
   21 r23 <- Ancestral { anc_name: AncestralName("R11"), reg_type: Bytes(8) }
   22 r24 <- Ancestral { anc_name: AncestralName("R12"), reg_type: Bytes(8) }
   23 r25 <- Ancestral { anc_name: AncestralName("R13"), reg_type: Bytes(8) }
   24 r26 <- Ancestral { anc_name: AncestralName("R14"), reg_type: Bytes(8) }
   25 r27 <- Ancestral { anc_name: AncestralName("R15"), reg_type: Bytes(8) }
   26 r28 <- Ancestral { anc_name: AncestralName("ZMM0"), reg_type: Bytes(64) }
   27 r29 <- Ancestral { anc_name: AncestralName("ZMM1"), reg_type: Bytes(64) }
   28 r30 <- Ancestral { anc_name: AncestralName("ZMM2"), reg_type: Bytes(64) }
   29 r31 <- Ancestral { anc_name: AncestralName("ZMM3"), reg_type: Bytes(64) }
   30 r32 <- Ancestral { anc_name: AncestralName("ZMM4"), reg_type: Bytes(64) }
   31 r33 <- Ancestral { anc_name: AncestralName("ZMM5"), reg_type: Bytes(64) }
   32 r34 <- Ancestral { anc_name: AncestralName("ZMM6"), reg_type: Bytes(64) }
   33 r35 <- Ancestral { anc_name: AncestralName("ZMM7"), reg_type: Bytes(64) }
   34 r36 <- Ancestral { anc_name: AncestralName("ZMM8"), reg_type: Bytes(64) }
   35 r37 <- Ancestral { anc_name: AncestralName("ZMM9"), reg_type: Bytes(64) }
   36 r38 <- Ancestral { anc_name: AncestralName("ZMM10"), reg_type: Bytes(64) }
   37 r39 <- Ancestral { anc_name: AncestralName("ZMM11"), reg_type: Bytes(64) }
   38 r40 <- Ancestral { anc_name: AncestralName("ZMM12"), reg_type: Bytes(64) }
   39 r41 <- Ancestral { anc_name: AncestralName("ZMM13"), reg_type: Bytes(64) }
   40 r42 <- Ancestral { anc_name: AncestralName("ZMM14"), reg_type: Bytes(64) }
   41 r43 <- Ancestral { anc_name: AncestralName("ZMM15"), reg_type: Bytes(64) }
   42 r45 <- FuncArgument { index: 0, reg_type: Bytes(8) }
   43 r14 <- Get(r45)
0x4110b0:
   44 r46 <- Int { value: 0, size: 8 }
   45 r46 <- Arith(Add, r46, r14)
   46 r45 <- LoadMem { addr: r46, size: 8 }
   47 r16 <- Get(r45)
0x4110b3:
   48 r16 <- Arith(BitAnd, r16, r16)
   49 r6 <- SignOf(r16)
   50 r5 <- IsZero(r16)
   51 r47 <- Part { src: r16, offset: 0, size: 1 }
   52 r3 <- Parity(r16)
   53 r2 <- False
   54 r10 <- False
0x4110b6:
   55 r45 <- SetJumpCondition(r5)
   56 r45 <- Control(JmpExtIf(4264150))
0x4110b8:
   57 r46 <- Int { value: 8, size: 8 }
   58 r46 <- Arith(Add, r46, r14)
   59 r45 <- LoadMem { addr: r46, size: 4 }
   60 r45 <- Widen { reg: r45, target_size: 8, sign: false }
   61 r19 <- Get(r45)
0x4110bb:
   62 r46 <- Part { src: r19, offset: 0, size: 4 }
   63 r48 <- Part { src: r19, offset: 0, size: 4 }
   64 r46 <- Arith(BitAnd, r46, r48)
   65 r6 <- SignOf(r46)
   66 r5 <- IsZero(r46)
   67 r49 <- Part { src: r46, offset: 0, size: 1 }
   68 r3 <- Parity(r46)
   69 r2 <- False
   70 r10 <- False
0x4110bd:
   71 r45 <- Not(r5)
   72 r46 <- SetJumpCondition(r45)
   73 r46 <- Control(JmpExtIf(4264144))
0x4110bf:
   74 r46 <- Int { value: 8, size: 8 }
   75 r46 <- Arith(Add, r46, r16)
   76 r45 <- LoadMem { addr: r46, size: 8 }
   77 r19 <- Get(r45)
0x4110c3:
   78 r46 <- Int { value: 0, size: 8 }
   79 r46 <- Arith(Add, r46, r14)
   80 r46 <- StoreMem { addr: r46, value: r19 }
0x4110c6:
   81 r45 <- Void
   82 r45 <- Concat { lo: r45, hi: r16 }
   83 r45 <- Part { src: r45, offset: 0, size: 8 }
   84 r47 <- SetReturnValue(r45)
   85 r47 <- Control(Ret)
0x4110d0:
   86 r46 <- Int { value: 0, size: 8 }
   87 r46 <- Arith(Add, r46, r16)
   88 r45 <- LoadMem { addr: r46, size: 8 }
   89 r19 <- Get(r45)
0x4110d3:
   90 r46 <- Int { value: 0, size: 8 }
   91 r46 <- Arith(Add, r46, r14)
   92 r46 <- StoreMem { addr: r46, value: r19 }
0x4110d6:
   93 r45 <- Void
   94 r45 <- Concat { lo: r45, hi: r16 }
   95 r45 <- Part { src: r45, offset: 0, size: 8 }
   96 r47 <- SetReturnValue(r45)
   97 r47 <- Control(Ret)


 --- ssa pre-xform
ssa program  98 instrs
.B0:    ;;  → Conditional { pos: Block(BlockID(4)), neg: Block(BlockID(1)) }.
  (  4)  r42: Bytes(8) <- FuncArgument { index: 0, reg_type: Bytes(8) }
         r44: Bytes(8) <- Int { value: 0, size: 8 }
         r45: Bytes(16) <- Arith(Add, r44, r42)
  (  2)  r46: Bytes(8) <- LoadMem { addr: r45, size: 8 }
  (  5)  r48: Bytes(16) <- Arith(BitAnd, r46, r46)
         r50: Bool <- IsZero(r48)
         r55: Effect <- SetJumpCondition(r50)
.B1:    ;; preds:B0  → Conditional { pos: Block(BlockID(3)), neg: Block(BlockID(2)) }.
         r57: Bytes(8) <- Int { value: 8, size: 8 }
         r58: Bytes(16) <- Arith(Add, r57, r42)
         r59: Bytes(4) <- LoadMem { addr: r58, size: 4 }
  (  2)  r60: Bytes(8) <- Widen { reg: r59, target_size: 8, sign: false }
         r62: Bytes(4) <- Part { src: r60, offset: 0, size: 4 }
         r63: Bytes(4) <- Part { src: r60, offset: 0, size: 4 }
         r64: Bytes(8) <- Arith(BitAnd, r62, r63)
         r66: Bool <- IsZero(r64)
         r71: Bool <- Not(r66)
         r72: Effect <- SetJumpCondition(r71)
.B2:    ;; preds:B1  → Always(Return).
         r74: Bytes(8) <- Int { value: 8, size: 8 }
         r75: Error <- Arith(Add, r74, r48)
         r76: Bytes(8) <- LoadMem { addr: r75, size: 8 }
         r78: Bytes(8) <- Int { value: 0, size: 8 }
         r79: Bytes(16) <- Arith(Add, r78, r42)
         r80: Effect <- StoreMem { addr: r79, value: r76 }
         r82: Bytes(16) <- Concat { lo: r81, hi: r48 }
         r83: Bytes(8) <- Part { src: r82, offset: 0, size: 8 }
         r84: Effect <- SetReturnValue(r83)
.B3:    ;; preds:B1  → Always(Block(BlockID(4))).
         r86: Bytes(8) <- Int { value: 0, size: 8 }
         r87: Error <- Arith(Add, r86, r48)
         r88: Bytes(8) <- LoadMem { addr: r87, size: 8 }
         r90: Bytes(8) <- Int { value: 0, size: 8 }
         r91: Bytes(16) <- Arith(Add, r90, r42)
         r92: Effect <- StoreMem { addr: r91, value: r88 }
.B4:    ;; preds:B0,B3  → Always(Return).
         r94: Bytes(16) <- Concat { lo: r93, hi: r48 }
         r95: Bytes(8) <- Part { src: r94, offset: 0, size: 8 }
         r96: Effect <- SetReturnValue(r95)


 --- cfg
  entry: BlockID(0)
  BlockID(0) -> Conditional { pos: Block(BlockID(4)), neg: Block(BlockID(1)) } [r42, r101, r99, r50, r55]
  BlockID(1) -> Conditional { pos: Block(BlockID(3)), neg: Block(BlockID(2)) } [r105, r103, r66, r71, r72]
  BlockID(2) -> Always(Return) [r109, r107, r80, r84]
  BlockID(3) -> Always(Block(BlockID(4))) [r113, r111, r92]
  BlockID(4) -> Always(Return) [r96]
  domtree:
    BlockID(0)
|  BlockID(1)
|  |  BlockID(2)
|  |  BlockID(3)
|  BlockID(4)

 --- ssa
ssa program  114 instrs
.B0:    ;;  → Conditional { pos: Block(BlockID(4)), neg: Block(BlockID(1)) }.
  (  4)  r42: Bytes(8) <- FuncArgument { index: 0, reg_type: Bytes(8) }
         r101: Bytes(16) <- LoadMem { addr: r42, size: 16 }
  (  5)  r99: Bytes(8) <- StructGetMember { struct_value: r101, name: "next", size: 8 }
         r50: Bool <- IsZero(r99)
         r55: Effect <- SetJumpCondition(r50)
.B1:    ;; preds:B0  → Conditional { pos: Block(BlockID(3)), neg: Block(BlockID(2)) }.
         r105: Bytes(16) <- LoadMem { addr: r42, size: 16 }
         r103: Bytes(4) <- StructGetMember { struct_value: r105, name: "direction", size: 4 }
         r66: Bool <- IsZero(r103)
         r71: Bool <- Not(r66)
         r72: Effect <- SetJumpCondition(r71)
.B2:    ;; preds:B1  → Always(Return).
         r109: Bytes(24) <- LoadMem { addr: r99, size: 24 }
         r107: Bytes(8) <- StructGetMember { struct_value: r109, name: "next", size: 8 }
         r80: Effect <- StoreMem { addr: r42, value: r107 }
         r84: Effect <- SetReturnValue(r99)
.B3:    ;; preds:B1  → Always(Block(BlockID(4))).
         r113: Bytes(24) <- LoadMem { addr: r99, size: 24 }
         r111: Bytes(8) <- StructGetMember { struct_value: r113, name: "prev", size: 8 }
         r92: Effect <- StoreMem { addr: r42, value: r111 }
.B4:    ;; preds:B0,B3  → Always(Return).
         r96: Effect <- SetReturnValue(r99)


 --- ast
# block order: B0, B1, B2, B3, B4
.B0: {
  let r42 = FuncArgument 0 Bytes(8);
  let r99 = StructGetMember (LoadMem r42 16) "next" 8;
  if IsZero r99
  then  jump .B4
  else  .B1: {
          if Not (IsZero (StructGetMember (LoadMem r42 16) "direction" 4))
          then  jump .B3
          else  .B2: {
                  StoreMem r42 (StructGetMember (LoadMem r99 24) "next" 8);
                  return r99
                }
        }
};
.B3: {
  StoreMem r42 (StructGetMember (LoadMem r99 24) "prev" 8);
  jump .B4
};
.B4: {
  return r99
}
