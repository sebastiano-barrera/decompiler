---
source: decompiler/tests/test_tool.rs
expression: out
---
 --- mil
program  95 instrs
    0 r12 <- Ancestral { anc_name: AncestralName("stack_bottom"), reg_type: Bytes(8) }
    1 r3 <- Ancestral { anc_name: AncestralName("PF"), reg_type: Bool }
    2 r4 <- Ancestral { anc_name: AncestralName("AF"), reg_type: Bool }
    3 r5 <- Ancestral { anc_name: AncestralName("ZF"), reg_type: Bool }
    4 r6 <- Ancestral { anc_name: AncestralName("SF"), reg_type: Bool }
    5 r7 <- Ancestral { anc_name: AncestralName("TF"), reg_type: Bool }
    6 r8 <- Ancestral { anc_name: AncestralName("IF"), reg_type: Bool }
    7 r9 <- Ancestral { anc_name: AncestralName("DF"), reg_type: Bool }
    8 r10 <- Ancestral { anc_name: AncestralName("OF"), reg_type: Bool }
    9 r11 <- Ancestral { anc_name: AncestralName("RBP"), reg_type: Bytes(8) }
   10 r12 <- Ancestral { anc_name: AncestralName("RSP"), reg_type: Bytes(8) }
   11 r13 <- Ancestral { anc_name: AncestralName("RIP"), reg_type: Bytes(8) }
   12 r14 <- Ancestral { anc_name: AncestralName("RDI"), reg_type: Bytes(8) }
   13 r15 <- Ancestral { anc_name: AncestralName("RSI"), reg_type: Bytes(8) }
   14 r16 <- Ancestral { anc_name: AncestralName("RAX"), reg_type: Bytes(8) }
   15 r17 <- Ancestral { anc_name: AncestralName("RBX"), reg_type: Bytes(8) }
   16 r18 <- Ancestral { anc_name: AncestralName("RCX"), reg_type: Bytes(8) }
   17 r19 <- Ancestral { anc_name: AncestralName("RDX"), reg_type: Bytes(8) }
   18 r20 <- Ancestral { anc_name: AncestralName("R8"), reg_type: Bytes(8) }
   19 r21 <- Ancestral { anc_name: AncestralName("R9"), reg_type: Bytes(8) }
   20 r22 <- Ancestral { anc_name: AncestralName("R10"), reg_type: Bytes(8) }
   21 r23 <- Ancestral { anc_name: AncestralName("R11"), reg_type: Bytes(8) }
   22 r24 <- Ancestral { anc_name: AncestralName("R12"), reg_type: Bytes(8) }
   23 r25 <- Ancestral { anc_name: AncestralName("R13"), reg_type: Bytes(8) }
   24 r26 <- Ancestral { anc_name: AncestralName("R14"), reg_type: Bytes(8) }
   25 r27 <- Ancestral { anc_name: AncestralName("R15"), reg_type: Bytes(8) }
   26 r28 <- Ancestral { anc_name: AncestralName("ZMM0"), reg_type: Bytes(64) }
   27 r29 <- Ancestral { anc_name: AncestralName("ZMM1"), reg_type: Bytes(64) }
   28 r30 <- Ancestral { anc_name: AncestralName("ZMM2"), reg_type: Bytes(64) }
   29 r31 <- Ancestral { anc_name: AncestralName("ZMM3"), reg_type: Bytes(64) }
   30 r32 <- Ancestral { anc_name: AncestralName("ZMM4"), reg_type: Bytes(64) }
   31 r33 <- Ancestral { anc_name: AncestralName("ZMM5"), reg_type: Bytes(64) }
   32 r34 <- Ancestral { anc_name: AncestralName("ZMM6"), reg_type: Bytes(64) }
   33 r35 <- Ancestral { anc_name: AncestralName("ZMM7"), reg_type: Bytes(64) }
   34 r36 <- Ancestral { anc_name: AncestralName("ZMM8"), reg_type: Bytes(64) }
   35 r37 <- Ancestral { anc_name: AncestralName("ZMM9"), reg_type: Bytes(64) }
   36 r38 <- Ancestral { anc_name: AncestralName("ZMM10"), reg_type: Bytes(64) }
   37 r39 <- Ancestral { anc_name: AncestralName("ZMM11"), reg_type: Bytes(64) }
   38 r40 <- Ancestral { anc_name: AncestralName("ZMM12"), reg_type: Bytes(64) }
   39 r41 <- Ancestral { anc_name: AncestralName("ZMM13"), reg_type: Bytes(64) }
   40 r42 <- Ancestral { anc_name: AncestralName("ZMM14"), reg_type: Bytes(64) }
   41 r43 <- Ancestral { anc_name: AncestralName("ZMM15"), reg_type: Bytes(64) }
   42 r45 <- FuncArgument { index: 0, reg_type: Bytes(24) }
   43 r47 <- Part { src: r45, offset: 0, size: 8 }
   44 r46 <- ArithK(Add, r12, 8)
   45 r46 <- StoreMem { addr: r46, value: r47 }
   46 r47 <- Part { src: r45, offset: 8, size: 8 }
   47 r46 <- ArithK(Add, r12, 16)
   48 r46 <- StoreMem { addr: r46, value: r47 }
   49 r47 <- Part { src: r45, offset: 16, size: 8 }
   50 r46 <- ArithK(Add, r12, 24)
   51 r46 <- StoreMem { addr: r46, value: r47 }
0x1120:
   52 r46 <- Part { src: r16, offset: 0, size: 4 }
   53 r48 <- Part { src: r16, offset: 0, size: 4 }
   54 r46 <- Arith(BitXor, r46, r48)
   55 r46 <- Widen { reg: r46, target_size: 8, sign: false }
   56 r16 <- Get(r46)
   57 r10 <- False
   58 r2 <- False
   59 r6 <- SignOf(r46)
   60 r5 <- IsZero(r46)
   61 r49 <- Part { src: r46, offset: 0, size: 1 }
   62 r3 <- Parity(r49)
0x1122:
   63 r45 <- Int { value: 8, size: 8 }
   64 r45 <- Arith(Add, r45, r12)
   65 r18 <- Get(r45)
0x1130:
   66 r46 <- Part { src: r16, offset: 0, size: 4 }
   67 r46 <- ArithK(Add, r46, 1)
   68 r46 <- Widen { reg: r46, target_size: 8, sign: false }
   69 r16 <- Get(r46)
   70 r10 <- False
   71 r2 <- False
   72 r6 <- SignOf(r46)
   73 r5 <- IsZero(r46)
   74 r47 <- Part { src: r46, offset: 0, size: 1 }
   75 r3 <- Parity(r47)
0x1132:
   76 r46 <- Int { value: 16, size: 8 }
   77 r46 <- Arith(Add, r46, r18)
   78 r45 <- LoadMem { addr: r46, size: 8 }
   79 r18 <- Get(r45)
0x1136:
   80 r18 <- Arith(BitAnd, r18, r18)
   81 r6 <- SignOf(r18)
   82 r5 <- IsZero(r18)
   83 r47 <- Part { src: r18, offset: 0, size: 1 }
   84 r3 <- Parity(r18)
   85 r2 <- False
   86 r10 <- False
0x1139:
   87 r45 <- Not(r5)
   88 r46 <- SetJumpCondition(r45)
   89 r46 <- Control(JmpExtIf(4400))
0x113b:
   90 r45 <- Void
   91 r45 <- Concat { lo: r45, hi: r16 }
   92 r45 <- Part { src: r45, offset: 0, size: 4 }
   93 r47 <- SetReturnValue(r45)
   94 r47 <- Control(Ret)


 --- ssa pre-xform
ssa program  101 instrs
.B0:    ;;  → Always(Block(BlockID(1))).
  (  4)  r10: Bytes(8) <- Ancestral { anc_name: AncestralName("RSP"), reg_type: Bytes(8) }
  (  2)  r14: Bytes(8) <- Ancestral { anc_name: AncestralName("RAX"), reg_type: Bytes(8) }
  (  3)  r42: Bytes(24) <- FuncArgument { index: 0, reg_type: Bytes(24) }
         r43: Bytes(8) <- Part { src: r42, offset: 0, size: 8 }
         r44: Bytes(16) <- ArithK(Add, r10, 8)
         r45: Effect <- StoreMem { addr: r44, value: r43 }
         r46: Bytes(8) <- Part { src: r42, offset: 8, size: 8 }
         r47: Bytes(16) <- ArithK(Add, r10, 16)
         r48: Effect <- StoreMem { addr: r47, value: r46 }
         r49: Bytes(8) <- Part { src: r42, offset: 16, size: 8 }
         r50: Bytes(16) <- ArithK(Add, r10, 24)
         r51: Effect <- StoreMem { addr: r50, value: r49 }
         r52: Bytes(4) <- Part { src: r14, offset: 0, size: 4 }
         r53: Bytes(4) <- Part { src: r14, offset: 0, size: 4 }
         r54: Bytes(8) <- Arith(BitXor, r52, r53)
         r55: Bytes(8) <- Widen { reg: r54, target_size: 8, sign: false }
         r63: Bytes(8) <- Int { value: 8, size: 8 }
         r64: Bytes(16) <- Arith(Add, r63, r10)
         r97: Effect <- Upsilon { value: r55, phi_ref: r95 }
         r98: Effect <- Upsilon { value: r64, phi_ref: r96 }
.B1:    ;; preds:B0,B1  → Conditional { pos: Block(BlockID(1)), neg: Block(BlockID(2)) }.
         r96: Error <- Phi
         r95: Error <- Phi
         r66: Bytes(4) <- Part { src: r95, offset: 0, size: 4 }
         r67: Bytes(8) <- ArithK(Add, r66, 1)
  (  2)  r68: Bytes(8) <- Widen { reg: r67, target_size: 8, sign: false }
         r76: Bytes(8) <- Int { value: 16, size: 8 }
         r77: Error <- Arith(Add, r76, r96)
  (  2)  r78: Bytes(8) <- LoadMem { addr: r77, size: 8 }
  (  2)  r80: Bytes(16) <- Arith(BitAnd, r78, r78)
         r82: Bool <- IsZero(r80)
         r87: Bool <- Not(r82)
         r88: Effect <- SetJumpCondition(r87)
         r99: Effect <- Upsilon { value: r68, phi_ref: r95 }
         r100: Effect <- Upsilon { value: r80, phi_ref: r96 }
.B2:    ;; preds:B1  → Always(Return).
         r91: Bytes(8) <- Concat { lo: r90, hi: r68 }
         r92: Bytes(4) <- Part { src: r91, offset: 0, size: 4 }
         r93: Effect <- SetReturnValue(r92)


 --- cfg
  entry: BlockID(0)
  BlockID(0) -> Always(Block(BlockID(1))) [r10, r14, r42, r43, r44, r45, r101, r47, r48, r102, r50, r51, r52, r53, r54, r64, r97, r98]
  BlockID(1) -> Conditional { pos: Block(BlockID(1)), neg: Block(BlockID(2)) } [r96, r95, r66, r67, r77, r78, r82, r87, r88, r99, r100]
  BlockID(2) -> Always(Return) [r92, r93]
  domtree:
    BlockID(0)
|  BlockID(1)
|  |  BlockID(2)

 --- ssa
ssa program  103 instrs
.B0:    ;;  → Always(Block(BlockID(1))).
  (  4)  r10: Bytes(8) <- Ancestral { anc_name: AncestralName("RSP"), reg_type: Bytes(8) }
  (  2)  r14: Bytes(8) <- Ancestral { anc_name: AncestralName("RAX"), reg_type: Bytes(8) }
  (  3)  r42: Bytes(24) <- FuncArgument { index: 0, reg_type: Bytes(24) }
         r43: Bytes(8) <- Part { src: r42, offset: 0, size: 8 }
         r44: Bytes(16) <- ArithK(Add, r10, 8)
         r45: Effect <- StoreMem { addr: r44, value: r43 }
         r101: Bytes(8) <- StructGetMember { struct_value: r42, name: "prev", size: 8 }
         r47: Bytes(16) <- ArithK(Add, r10, 16)
         r48: Effect <- StoreMem { addr: r47, value: r101 }
         r102: Bytes(8) <- StructGetMember { struct_value: r42, name: "next", size: 8 }
         r50: Bytes(16) <- ArithK(Add, r10, 24)
         r51: Effect <- StoreMem { addr: r50, value: r102 }
         r52: Bytes(4) <- Part { src: r14, offset: 0, size: 4 }
         r53: Bytes(4) <- Part { src: r14, offset: 0, size: 4 }
         r54: Bytes(8) <- Arith(BitXor, r52, r53)
         r64: Bytes(16) <- ArithK(Add, r10, 8)
         r97: Effect <- Upsilon { value: r54, phi_ref: r95 }
         r98: Effect <- Upsilon { value: r64, phi_ref: r96 }
.B1:    ;; preds:B0,B1  → Conditional { pos: Block(BlockID(1)), neg: Block(BlockID(2)) }.
         r96: Error <- Phi
         r95: Bytes(8) <- Phi
         r66: Bytes(4) <- Part { src: r95, offset: 0, size: 4 }
  (  2)  r67: Bytes(8) <- ArithK(Add, r66, 1)
         r77: Error <- ArithK(Add, r96, 16)
  (  2)  r78: Bytes(8) <- LoadMem { addr: r77, size: 8 }
         r82: Bool <- IsZero(r78)
         r87: Bool <- Not(r82)
         r88: Effect <- SetJumpCondition(r87)
         r99: Effect <- Upsilon { value: r67, phi_ref: r95 }
         r100: Effect <- Upsilon { value: r78, phi_ref: r96 }
.B2:    ;; preds:B1  → Always(Return).
         r92: Bytes(4) <- Part { src: r67, offset: 0, size: 4 }
         r93: Effect <- SetReturnValue(r92)


 --- ast
# block order: B0, B1, B2
.B0: {
  let r42 = FuncArgument 0 Bytes(24);
  StoreMem (ArithK Add (Ancestral AncestralName("RSP") Bytes(8)) 8) (Part r42 0 8);
  StoreMem (ArithK Add (Ancestral AncestralName("RSP") Bytes(8)) 16) (StructGetMember r42 "prev" 8);
  StoreMem (ArithK Add (Ancestral AncestralName("RSP") Bytes(8)) 24) (StructGetMember r42 "next" 8);
  Upsilon (Arith BitXor (Part (Ancestral AncestralName("RAX") Bytes(8)) 0 4) (Part (Ancestral AncestralName("RAX") Bytes(8)) 0 4)) r95;
  Upsilon (ArithK Add (Ancestral AncestralName("RSP") Bytes(8)) 8) r96;
  jump .B1
};
.B1: {
  r96: phi;
  r95: phi;
  let r67 = ArithK Add (Part r95 0 4) 1;
  let r78 = LoadMem (ArithK Add r96 16) 8;
  Upsilon r67 r95;
  Upsilon r78 r96;
  if Not (IsZero r78)
  then  jump .B1
  else  .B2: {
          return Part r67 0 4
        }
}
